// Generated by Ignite ignite.com/cli

import { SigningStargateClient, DeliverTxResponse, StdFee } from "@cosmjs/stargate";
import { EncodeObject, GeneratedType, OfflineSigner, Registry } from "@cosmjs/proto-signing";
import { msgTypes } from './registry';
import { IgniteClient } from "../client"
import { MissingWalletError } from "../helpers"
import { Api } from "./rest";
import { Params } from "./types/arkeo/arkeo/params";
import { QueryFetchContractRequest } from "./types/arkeo/arkeo/query";
import { MsgBondProvider } from "./types/arkeo/arkeo/tx";
import { MsgClaimContractIncome } from "./types/arkeo/arkeo/tx";
import { EventModProvider } from "./types/arkeo/arkeo/events";
import { QueryAllContractResponse } from "./types/arkeo/arkeo/query";
import { ProtoStrings } from "./types/arkeo/arkeo/misc";
import { GenesisState } from "./types/arkeo/arkeo/genesis";
import { Contract } from "./types/arkeo/arkeo/keeper";
import { ContractExpirationSet } from "./types/arkeo/arkeo/keeper";
import { MsgOpenContractResponse } from "./types/arkeo/arkeo/tx";
import { EventOpenContract } from "./types/arkeo/arkeo/events";
import { QueryParamsResponse } from "./types/arkeo/arkeo/query";
import { MsgCloseContractResponse } from "./types/arkeo/arkeo/tx";
import { ProtoInt64 } from "./types/arkeo/arkeo/misc";
import { ProtoUint64 } from "./types/arkeo/arkeo/misc";
import { QueryAllProviderRequest } from "./types/arkeo/arkeo/query";
import { MsgClaimContractIncomeResponse } from "./types/arkeo/arkeo/tx";
import { MsgSetVersion } from "./types/arkeo/arkeo/tx";
import { UserContractSet } from "./types/arkeo/arkeo/keeper";
import { QueryActiveContractRequest } from "./types/arkeo/arkeo/query";
import { MsgModProviderResponse } from "./types/arkeo/arkeo/tx";
import { MsgSetVersionResponse } from "./types/arkeo/arkeo/tx";
import { MsgModProvider } from "./types/arkeo/arkeo/tx";
import { EventCloseContract } from "./types/arkeo/arkeo/events";
import { QueryAllContractRequest } from "./types/arkeo/arkeo/query";
import { ProtoBools } from "./types/arkeo/arkeo/misc";
import { EventSettleContract } from "./types/arkeo/arkeo/events";
import { QueryActiveContractResponse } from "./types/arkeo/arkeo/query";
import { EventBondProvider } from "./types/arkeo/arkeo/events";
import { QueryFetchContractResponse } from "./types/arkeo/arkeo/query";
import { MsgBondProviderResponse } from "./types/arkeo/arkeo/tx";
import { EventValidatorPayout } from "./types/arkeo/arkeo/events";
import { QueryAllProviderResponse } from "./types/arkeo/arkeo/query";
import { MsgOpenContract } from "./types/arkeo/arkeo/tx";
import { QueryParamsRequest } from "./types/arkeo/arkeo/query";
import { QueryFetchProviderRequest } from "./types/arkeo/arkeo/query";
import { ProtoAccAddresses } from "./types/arkeo/arkeo/misc";
import { MsgCloseContract } from "./types/arkeo/arkeo/tx";
import { Provider } from "./types/arkeo/arkeo/keeper";
import { ContractSet } from "./types/arkeo/arkeo/keeper";
import { QueryFetchProviderResponse } from "./types/arkeo/arkeo/query";


export { Params, QueryFetchContractRequest, MsgBondProvider, MsgClaimContractIncome, EventModProvider, QueryAllContractResponse, ProtoStrings, GenesisState, Contract, ContractExpirationSet, MsgOpenContractResponse, EventOpenContract, QueryParamsResponse, MsgCloseContractResponse, ProtoInt64, ProtoUint64, QueryAllProviderRequest, MsgClaimContractIncomeResponse, MsgSetVersion, UserContractSet, QueryActiveContractRequest, MsgModProviderResponse, MsgSetVersionResponse, MsgModProvider, EventCloseContract, QueryAllContractRequest, ProtoBools, EventSettleContract, QueryActiveContractResponse, EventBondProvider, QueryFetchContractResponse, MsgBondProviderResponse, EventValidatorPayout, QueryAllProviderResponse, MsgOpenContract, QueryParamsRequest, QueryFetchProviderRequest, ProtoAccAddresses, MsgCloseContract, Provider, ContractSet, QueryFetchProviderResponse };

type sendParamsParams = {
  value: Params,
  fee?: StdFee,
  memo?: string
};

type sendQueryFetchContractRequestParams = {
  value: QueryFetchContractRequest,
  fee?: StdFee,
  memo?: string
};

type sendMsgBondProviderParams = {
  value: MsgBondProvider,
  fee?: StdFee,
  memo?: string
};

type sendMsgClaimContractIncomeParams = {
  value: MsgClaimContractIncome,
  fee?: StdFee,
  memo?: string
};

type sendEventModProviderParams = {
  value: EventModProvider,
  fee?: StdFee,
  memo?: string
};

type sendQueryAllContractResponseParams = {
  value: QueryAllContractResponse,
  fee?: StdFee,
  memo?: string
};

type sendProtoStringsParams = {
  value: ProtoStrings,
  fee?: StdFee,
  memo?: string
};

type sendGenesisStateParams = {
  value: GenesisState,
  fee?: StdFee,
  memo?: string
};

type sendContractParams = {
  value: Contract,
  fee?: StdFee,
  memo?: string
};

type sendContractExpirationSetParams = {
  value: ContractExpirationSet,
  fee?: StdFee,
  memo?: string
};

type sendMsgOpenContractResponseParams = {
  value: MsgOpenContractResponse,
  fee?: StdFee,
  memo?: string
};

type sendEventOpenContractParams = {
  value: EventOpenContract,
  fee?: StdFee,
  memo?: string
};

type sendQueryParamsResponseParams = {
  value: QueryParamsResponse,
  fee?: StdFee,
  memo?: string
};

type sendMsgCloseContractResponseParams = {
  value: MsgCloseContractResponse,
  fee?: StdFee,
  memo?: string
};

type sendProtoInt64Params = {
  value: ProtoInt64,
  fee?: StdFee,
  memo?: string
};

type sendProtoUint64Params = {
  value: ProtoUint64,
  fee?: StdFee,
  memo?: string
};

type sendQueryAllProviderRequestParams = {
  value: QueryAllProviderRequest,
  fee?: StdFee,
  memo?: string
};

type sendMsgClaimContractIncomeResponseParams = {
  value: MsgClaimContractIncomeResponse,
  fee?: StdFee,
  memo?: string
};

type sendMsgSetVersionParams = {
  value: MsgSetVersion,
  fee?: StdFee,
  memo?: string
};

type sendUserContractSetParams = {
  value: UserContractSet,
  fee?: StdFee,
  memo?: string
};

type sendQueryActiveContractRequestParams = {
  value: QueryActiveContractRequest,
  fee?: StdFee,
  memo?: string
};

type sendMsgModProviderResponseParams = {
  value: MsgModProviderResponse,
  fee?: StdFee,
  memo?: string
};

type sendMsgSetVersionResponseParams = {
  value: MsgSetVersionResponse,
  fee?: StdFee,
  memo?: string
};

type sendMsgModProviderParams = {
  value: MsgModProvider,
  fee?: StdFee,
  memo?: string
};

type sendEventCloseContractParams = {
  value: EventCloseContract,
  fee?: StdFee,
  memo?: string
};

type sendQueryAllContractRequestParams = {
  value: QueryAllContractRequest,
  fee?: StdFee,
  memo?: string
};

type sendProtoBoolsParams = {
  value: ProtoBools,
  fee?: StdFee,
  memo?: string
};

type sendEventSettleContractParams = {
  value: EventSettleContract,
  fee?: StdFee,
  memo?: string
};

type sendQueryActiveContractResponseParams = {
  value: QueryActiveContractResponse,
  fee?: StdFee,
  memo?: string
};

type sendEventBondProviderParams = {
  value: EventBondProvider,
  fee?: StdFee,
  memo?: string
};

type sendQueryFetchContractResponseParams = {
  value: QueryFetchContractResponse,
  fee?: StdFee,
  memo?: string
};

type sendMsgBondProviderResponseParams = {
  value: MsgBondProviderResponse,
  fee?: StdFee,
  memo?: string
};

type sendEventValidatorPayoutParams = {
  value: EventValidatorPayout,
  fee?: StdFee,
  memo?: string
};

type sendQueryAllProviderResponseParams = {
  value: QueryAllProviderResponse,
  fee?: StdFee,
  memo?: string
};

type sendMsgOpenContractParams = {
  value: MsgOpenContract,
  fee?: StdFee,
  memo?: string
};

type sendQueryParamsRequestParams = {
  value: QueryParamsRequest,
  fee?: StdFee,
  memo?: string
};

type sendQueryFetchProviderRequestParams = {
  value: QueryFetchProviderRequest,
  fee?: StdFee,
  memo?: string
};

type sendProtoAccAddressesParams = {
  value: ProtoAccAddresses,
  fee?: StdFee,
  memo?: string
};

type sendMsgCloseContractParams = {
  value: MsgCloseContract,
  fee?: StdFee,
  memo?: string
};

type sendProviderParams = {
  value: Provider,
  fee?: StdFee,
  memo?: string
};

type sendContractSetParams = {
  value: ContractSet,
  fee?: StdFee,
  memo?: string
};

type sendQueryFetchProviderResponseParams = {
  value: QueryFetchProviderResponse,
  fee?: StdFee,
  memo?: string
};


type paramsParams = {
  value: Params,
};

type queryFetchContractRequestParams = {
  value: QueryFetchContractRequest,
};

type msgBondProviderParams = {
  value: MsgBondProvider,
};

type msgClaimContractIncomeParams = {
  value: MsgClaimContractIncome,
};

type eventModProviderParams = {
  value: EventModProvider,
};

type queryAllContractResponseParams = {
  value: QueryAllContractResponse,
};

type protoStringsParams = {
  value: ProtoStrings,
};

type genesisStateParams = {
  value: GenesisState,
};

type contractParams = {
  value: Contract,
};

type contractExpirationSetParams = {
  value: ContractExpirationSet,
};

type msgOpenContractResponseParams = {
  value: MsgOpenContractResponse,
};

type eventOpenContractParams = {
  value: EventOpenContract,
};

type queryParamsResponseParams = {
  value: QueryParamsResponse,
};

type msgCloseContractResponseParams = {
  value: MsgCloseContractResponse,
};

type protoInt64Params = {
  value: ProtoInt64,
};

type protoUint64Params = {
  value: ProtoUint64,
};

type queryAllProviderRequestParams = {
  value: QueryAllProviderRequest,
};

type msgClaimContractIncomeResponseParams = {
  value: MsgClaimContractIncomeResponse,
};

type msgSetVersionParams = {
  value: MsgSetVersion,
};

type userContractSetParams = {
  value: UserContractSet,
};

type queryActiveContractRequestParams = {
  value: QueryActiveContractRequest,
};

type msgModProviderResponseParams = {
  value: MsgModProviderResponse,
};

type msgSetVersionResponseParams = {
  value: MsgSetVersionResponse,
};

type msgModProviderParams = {
  value: MsgModProvider,
};

type eventCloseContractParams = {
  value: EventCloseContract,
};

type queryAllContractRequestParams = {
  value: QueryAllContractRequest,
};

type protoBoolsParams = {
  value: ProtoBools,
};

type eventSettleContractParams = {
  value: EventSettleContract,
};

type queryActiveContractResponseParams = {
  value: QueryActiveContractResponse,
};

type eventBondProviderParams = {
  value: EventBondProvider,
};

type queryFetchContractResponseParams = {
  value: QueryFetchContractResponse,
};

type msgBondProviderResponseParams = {
  value: MsgBondProviderResponse,
};

type eventValidatorPayoutParams = {
  value: EventValidatorPayout,
};

type queryAllProviderResponseParams = {
  value: QueryAllProviderResponse,
};

type msgOpenContractParams = {
  value: MsgOpenContract,
};

type queryParamsRequestParams = {
  value: QueryParamsRequest,
};

type queryFetchProviderRequestParams = {
  value: QueryFetchProviderRequest,
};

type protoAccAddressesParams = {
  value: ProtoAccAddresses,
};

type msgCloseContractParams = {
  value: MsgCloseContract,
};

type providerParams = {
  value: Provider,
};

type contractSetParams = {
  value: ContractSet,
};

type queryFetchProviderResponseParams = {
  value: QueryFetchProviderResponse,
};


export const registry = new Registry(msgTypes);

type Field = {
	name: string;
	type: unknown;
}
function getStructure(template) {
	const structure: {fields: Field[]} = { fields: [] }
	for (let [key, value] of Object.entries(template)) {
		let field = { name: key, type: typeof value }
		structure.fields.push(field)
	}
	return structure
}
const defaultFee = {
  amount: [],
  gas: "200000",
};

interface TxClientOptions {
  addr: string
	prefix: string
	signer?: OfflineSigner
}

export const txClient = ({ signer, prefix, addr }: TxClientOptions = { addr: "http://localhost:26657", prefix: "cosmos" }) => {

  return {
		
		async sendParams({ value, fee, memo }: sendParamsParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendParams: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.params({ value: Params.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendParams: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendQueryFetchContractRequest({ value, fee, memo }: sendQueryFetchContractRequestParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendQueryFetchContractRequest: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.queryFetchContractRequest({ value: QueryFetchContractRequest.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendQueryFetchContractRequest: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgBondProvider({ value, fee, memo }: sendMsgBondProviderParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgBondProvider: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.msgBondProvider({ value: MsgBondProvider.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgBondProvider: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgClaimContractIncome({ value, fee, memo }: sendMsgClaimContractIncomeParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgClaimContractIncome: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.msgClaimContractIncome({ value: MsgClaimContractIncome.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgClaimContractIncome: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendEventModProvider({ value, fee, memo }: sendEventModProviderParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendEventModProvider: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.eventModProvider({ value: EventModProvider.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendEventModProvider: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendQueryAllContractResponse({ value, fee, memo }: sendQueryAllContractResponseParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendQueryAllContractResponse: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.queryAllContractResponse({ value: QueryAllContractResponse.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendQueryAllContractResponse: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendProtoStrings({ value, fee, memo }: sendProtoStringsParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendProtoStrings: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.protoStrings({ value: ProtoStrings.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendProtoStrings: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendGenesisState({ value, fee, memo }: sendGenesisStateParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendGenesisState: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.genesisState({ value: GenesisState.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendGenesisState: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendContract({ value, fee, memo }: sendContractParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendContract: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.contract({ value: Contract.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendContract: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendContractExpirationSet({ value, fee, memo }: sendContractExpirationSetParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendContractExpirationSet: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.contractExpirationSet({ value: ContractExpirationSet.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendContractExpirationSet: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgOpenContractResponse({ value, fee, memo }: sendMsgOpenContractResponseParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgOpenContractResponse: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.msgOpenContractResponse({ value: MsgOpenContractResponse.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgOpenContractResponse: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendEventOpenContract({ value, fee, memo }: sendEventOpenContractParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendEventOpenContract: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.eventOpenContract({ value: EventOpenContract.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendEventOpenContract: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendQueryParamsResponse({ value, fee, memo }: sendQueryParamsResponseParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendQueryParamsResponse: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.queryParamsResponse({ value: QueryParamsResponse.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendQueryParamsResponse: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgCloseContractResponse({ value, fee, memo }: sendMsgCloseContractResponseParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgCloseContractResponse: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.msgCloseContractResponse({ value: MsgCloseContractResponse.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgCloseContractResponse: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendProtoInt64({ value, fee, memo }: sendProtoInt64Params): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendProtoInt64: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.protoInt64({ value: ProtoInt64.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendProtoInt64: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendProtoUint64({ value, fee, memo }: sendProtoUint64Params): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendProtoUint64: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.protoUint64({ value: ProtoUint64.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendProtoUint64: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendQueryAllProviderRequest({ value, fee, memo }: sendQueryAllProviderRequestParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendQueryAllProviderRequest: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.queryAllProviderRequest({ value: QueryAllProviderRequest.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendQueryAllProviderRequest: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgClaimContractIncomeResponse({ value, fee, memo }: sendMsgClaimContractIncomeResponseParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgClaimContractIncomeResponse: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.msgClaimContractIncomeResponse({ value: MsgClaimContractIncomeResponse.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgClaimContractIncomeResponse: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgSetVersion({ value, fee, memo }: sendMsgSetVersionParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgSetVersion: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.msgSetVersion({ value: MsgSetVersion.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgSetVersion: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendUserContractSet({ value, fee, memo }: sendUserContractSetParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendUserContractSet: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.userContractSet({ value: UserContractSet.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendUserContractSet: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendQueryActiveContractRequest({ value, fee, memo }: sendQueryActiveContractRequestParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendQueryActiveContractRequest: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.queryActiveContractRequest({ value: QueryActiveContractRequest.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendQueryActiveContractRequest: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgModProviderResponse({ value, fee, memo }: sendMsgModProviderResponseParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgModProviderResponse: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.msgModProviderResponse({ value: MsgModProviderResponse.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgModProviderResponse: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgSetVersionResponse({ value, fee, memo }: sendMsgSetVersionResponseParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgSetVersionResponse: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.msgSetVersionResponse({ value: MsgSetVersionResponse.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgSetVersionResponse: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgModProvider({ value, fee, memo }: sendMsgModProviderParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgModProvider: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.msgModProvider({ value: MsgModProvider.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgModProvider: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendEventCloseContract({ value, fee, memo }: sendEventCloseContractParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendEventCloseContract: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.eventCloseContract({ value: EventCloseContract.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendEventCloseContract: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendQueryAllContractRequest({ value, fee, memo }: sendQueryAllContractRequestParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendQueryAllContractRequest: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.queryAllContractRequest({ value: QueryAllContractRequest.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendQueryAllContractRequest: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendProtoBools({ value, fee, memo }: sendProtoBoolsParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendProtoBools: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.protoBools({ value: ProtoBools.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendProtoBools: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendEventSettleContract({ value, fee, memo }: sendEventSettleContractParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendEventSettleContract: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.eventSettleContract({ value: EventSettleContract.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendEventSettleContract: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendQueryActiveContractResponse({ value, fee, memo }: sendQueryActiveContractResponseParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendQueryActiveContractResponse: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.queryActiveContractResponse({ value: QueryActiveContractResponse.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendQueryActiveContractResponse: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendEventBondProvider({ value, fee, memo }: sendEventBondProviderParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendEventBondProvider: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.eventBondProvider({ value: EventBondProvider.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendEventBondProvider: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendQueryFetchContractResponse({ value, fee, memo }: sendQueryFetchContractResponseParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendQueryFetchContractResponse: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.queryFetchContractResponse({ value: QueryFetchContractResponse.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendQueryFetchContractResponse: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgBondProviderResponse({ value, fee, memo }: sendMsgBondProviderResponseParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgBondProviderResponse: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.msgBondProviderResponse({ value: MsgBondProviderResponse.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgBondProviderResponse: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendEventValidatorPayout({ value, fee, memo }: sendEventValidatorPayoutParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendEventValidatorPayout: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.eventValidatorPayout({ value: EventValidatorPayout.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendEventValidatorPayout: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendQueryAllProviderResponse({ value, fee, memo }: sendQueryAllProviderResponseParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendQueryAllProviderResponse: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.queryAllProviderResponse({ value: QueryAllProviderResponse.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendQueryAllProviderResponse: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgOpenContract({ value, fee, memo }: sendMsgOpenContractParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgOpenContract: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.msgOpenContract({ value: MsgOpenContract.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgOpenContract: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendQueryParamsRequest({ value, fee, memo }: sendQueryParamsRequestParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendQueryParamsRequest: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.queryParamsRequest({ value: QueryParamsRequest.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendQueryParamsRequest: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendQueryFetchProviderRequest({ value, fee, memo }: sendQueryFetchProviderRequestParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendQueryFetchProviderRequest: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.queryFetchProviderRequest({ value: QueryFetchProviderRequest.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendQueryFetchProviderRequest: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendProtoAccAddresses({ value, fee, memo }: sendProtoAccAddressesParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendProtoAccAddresses: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.protoAccAddresses({ value: ProtoAccAddresses.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendProtoAccAddresses: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgCloseContract({ value, fee, memo }: sendMsgCloseContractParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgCloseContract: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.msgCloseContract({ value: MsgCloseContract.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgCloseContract: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendProvider({ value, fee, memo }: sendProviderParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendProvider: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.provider({ value: Provider.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendProvider: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendContractSet({ value, fee, memo }: sendContractSetParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendContractSet: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.contractSet({ value: ContractSet.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendContractSet: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendQueryFetchProviderResponse({ value, fee, memo }: sendQueryFetchProviderResponseParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendQueryFetchProviderResponse: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.queryFetchProviderResponse({ value: QueryFetchProviderResponse.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendQueryFetchProviderResponse: Could not broadcast Tx: '+ e.message)
			}
		},
		
		
		params({ value }: paramsParams): EncodeObject {
			try {
				return { typeUrl: "/arkeo.arkeo.Params", value: Params.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:Params: Could not create message: ' + e.message)
			}
		},
		
		queryFetchContractRequest({ value }: queryFetchContractRequestParams): EncodeObject {
			try {
				return { typeUrl: "/arkeo.arkeo.QueryFetchContractRequest", value: QueryFetchContractRequest.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:QueryFetchContractRequest: Could not create message: ' + e.message)
			}
		},
		
		msgBondProvider({ value }: msgBondProviderParams): EncodeObject {
			try {
				return { typeUrl: "/arkeo.arkeo.MsgBondProvider", value: MsgBondProvider.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgBondProvider: Could not create message: ' + e.message)
			}
		},
		
		msgClaimContractIncome({ value }: msgClaimContractIncomeParams): EncodeObject {
			try {
				return { typeUrl: "/arkeo.arkeo.MsgClaimContractIncome", value: MsgClaimContractIncome.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgClaimContractIncome: Could not create message: ' + e.message)
			}
		},
		
		eventModProvider({ value }: eventModProviderParams): EncodeObject {
			try {
				return { typeUrl: "/arkeo.arkeo.EventModProvider", value: EventModProvider.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:EventModProvider: Could not create message: ' + e.message)
			}
		},
		
		queryAllContractResponse({ value }: queryAllContractResponseParams): EncodeObject {
			try {
				return { typeUrl: "/arkeo.arkeo.QueryAllContractResponse", value: QueryAllContractResponse.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:QueryAllContractResponse: Could not create message: ' + e.message)
			}
		},
		
		protoStrings({ value }: protoStringsParams): EncodeObject {
			try {
				return { typeUrl: "/arkeo.arkeo.ProtoStrings", value: ProtoStrings.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:ProtoStrings: Could not create message: ' + e.message)
			}
		},
		
		genesisState({ value }: genesisStateParams): EncodeObject {
			try {
				return { typeUrl: "/arkeo.arkeo.GenesisState", value: GenesisState.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:GenesisState: Could not create message: ' + e.message)
			}
		},
		
		contract({ value }: contractParams): EncodeObject {
			try {
				return { typeUrl: "/arkeo.arkeo.Contract", value: Contract.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:Contract: Could not create message: ' + e.message)
			}
		},
		
		contractExpirationSet({ value }: contractExpirationSetParams): EncodeObject {
			try {
				return { typeUrl: "/arkeo.arkeo.ContractExpirationSet", value: ContractExpirationSet.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:ContractExpirationSet: Could not create message: ' + e.message)
			}
		},
		
		msgOpenContractResponse({ value }: msgOpenContractResponseParams): EncodeObject {
			try {
				return { typeUrl: "/arkeo.arkeo.MsgOpenContractResponse", value: MsgOpenContractResponse.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgOpenContractResponse: Could not create message: ' + e.message)
			}
		},
		
		eventOpenContract({ value }: eventOpenContractParams): EncodeObject {
			try {
				return { typeUrl: "/arkeo.arkeo.EventOpenContract", value: EventOpenContract.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:EventOpenContract: Could not create message: ' + e.message)
			}
		},
		
		queryParamsResponse({ value }: queryParamsResponseParams): EncodeObject {
			try {
				return { typeUrl: "/arkeo.arkeo.QueryParamsResponse", value: QueryParamsResponse.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:QueryParamsResponse: Could not create message: ' + e.message)
			}
		},
		
		msgCloseContractResponse({ value }: msgCloseContractResponseParams): EncodeObject {
			try {
				return { typeUrl: "/arkeo.arkeo.MsgCloseContractResponse", value: MsgCloseContractResponse.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgCloseContractResponse: Could not create message: ' + e.message)
			}
		},
		
		protoInt64({ value }: protoInt64Params): EncodeObject {
			try {
				return { typeUrl: "/arkeo.arkeo.ProtoInt64", value: ProtoInt64.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:ProtoInt64: Could not create message: ' + e.message)
			}
		},
		
		protoUint64({ value }: protoUint64Params): EncodeObject {
			try {
				return { typeUrl: "/arkeo.arkeo.ProtoUint64", value: ProtoUint64.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:ProtoUint64: Could not create message: ' + e.message)
			}
		},
		
		queryAllProviderRequest({ value }: queryAllProviderRequestParams): EncodeObject {
			try {
				return { typeUrl: "/arkeo.arkeo.QueryAllProviderRequest", value: QueryAllProviderRequest.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:QueryAllProviderRequest: Could not create message: ' + e.message)
			}
		},
		
		msgClaimContractIncomeResponse({ value }: msgClaimContractIncomeResponseParams): EncodeObject {
			try {
				return { typeUrl: "/arkeo.arkeo.MsgClaimContractIncomeResponse", value: MsgClaimContractIncomeResponse.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgClaimContractIncomeResponse: Could not create message: ' + e.message)
			}
		},
		
		msgSetVersion({ value }: msgSetVersionParams): EncodeObject {
			try {
				return { typeUrl: "/arkeo.arkeo.MsgSetVersion", value: MsgSetVersion.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgSetVersion: Could not create message: ' + e.message)
			}
		},
		
		userContractSet({ value }: userContractSetParams): EncodeObject {
			try {
				return { typeUrl: "/arkeo.arkeo.UserContractSet", value: UserContractSet.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:UserContractSet: Could not create message: ' + e.message)
			}
		},
		
		queryActiveContractRequest({ value }: queryActiveContractRequestParams): EncodeObject {
			try {
				return { typeUrl: "/arkeo.arkeo.QueryActiveContractRequest", value: QueryActiveContractRequest.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:QueryActiveContractRequest: Could not create message: ' + e.message)
			}
		},
		
		msgModProviderResponse({ value }: msgModProviderResponseParams): EncodeObject {
			try {
				return { typeUrl: "/arkeo.arkeo.MsgModProviderResponse", value: MsgModProviderResponse.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgModProviderResponse: Could not create message: ' + e.message)
			}
		},
		
		msgSetVersionResponse({ value }: msgSetVersionResponseParams): EncodeObject {
			try {
				return { typeUrl: "/arkeo.arkeo.MsgSetVersionResponse", value: MsgSetVersionResponse.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgSetVersionResponse: Could not create message: ' + e.message)
			}
		},
		
		msgModProvider({ value }: msgModProviderParams): EncodeObject {
			try {
				return { typeUrl: "/arkeo.arkeo.MsgModProvider", value: MsgModProvider.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgModProvider: Could not create message: ' + e.message)
			}
		},
		
		eventCloseContract({ value }: eventCloseContractParams): EncodeObject {
			try {
				return { typeUrl: "/arkeo.arkeo.EventCloseContract", value: EventCloseContract.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:EventCloseContract: Could not create message: ' + e.message)
			}
		},
		
		queryAllContractRequest({ value }: queryAllContractRequestParams): EncodeObject {
			try {
				return { typeUrl: "/arkeo.arkeo.QueryAllContractRequest", value: QueryAllContractRequest.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:QueryAllContractRequest: Could not create message: ' + e.message)
			}
		},
		
		protoBools({ value }: protoBoolsParams): EncodeObject {
			try {
				return { typeUrl: "/arkeo.arkeo.ProtoBools", value: ProtoBools.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:ProtoBools: Could not create message: ' + e.message)
			}
		},
		
		eventSettleContract({ value }: eventSettleContractParams): EncodeObject {
			try {
				return { typeUrl: "/arkeo.arkeo.EventSettleContract", value: EventSettleContract.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:EventSettleContract: Could not create message: ' + e.message)
			}
		},
		
		queryActiveContractResponse({ value }: queryActiveContractResponseParams): EncodeObject {
			try {
				return { typeUrl: "/arkeo.arkeo.QueryActiveContractResponse", value: QueryActiveContractResponse.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:QueryActiveContractResponse: Could not create message: ' + e.message)
			}
		},
		
		eventBondProvider({ value }: eventBondProviderParams): EncodeObject {
			try {
				return { typeUrl: "/arkeo.arkeo.EventBondProvider", value: EventBondProvider.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:EventBondProvider: Could not create message: ' + e.message)
			}
		},
		
		queryFetchContractResponse({ value }: queryFetchContractResponseParams): EncodeObject {
			try {
				return { typeUrl: "/arkeo.arkeo.QueryFetchContractResponse", value: QueryFetchContractResponse.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:QueryFetchContractResponse: Could not create message: ' + e.message)
			}
		},
		
		msgBondProviderResponse({ value }: msgBondProviderResponseParams): EncodeObject {
			try {
				return { typeUrl: "/arkeo.arkeo.MsgBondProviderResponse", value: MsgBondProviderResponse.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgBondProviderResponse: Could not create message: ' + e.message)
			}
		},
		
		eventValidatorPayout({ value }: eventValidatorPayoutParams): EncodeObject {
			try {
				return { typeUrl: "/arkeo.arkeo.EventValidatorPayout", value: EventValidatorPayout.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:EventValidatorPayout: Could not create message: ' + e.message)
			}
		},
		
		queryAllProviderResponse({ value }: queryAllProviderResponseParams): EncodeObject {
			try {
				return { typeUrl: "/arkeo.arkeo.QueryAllProviderResponse", value: QueryAllProviderResponse.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:QueryAllProviderResponse: Could not create message: ' + e.message)
			}
		},
		
		msgOpenContract({ value }: msgOpenContractParams): EncodeObject {
			try {
				return { typeUrl: "/arkeo.arkeo.MsgOpenContract", value: MsgOpenContract.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgOpenContract: Could not create message: ' + e.message)
			}
		},
		
		queryParamsRequest({ value }: queryParamsRequestParams): EncodeObject {
			try {
				return { typeUrl: "/arkeo.arkeo.QueryParamsRequest", value: QueryParamsRequest.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:QueryParamsRequest: Could not create message: ' + e.message)
			}
		},
		
		queryFetchProviderRequest({ value }: queryFetchProviderRequestParams): EncodeObject {
			try {
				return { typeUrl: "/arkeo.arkeo.QueryFetchProviderRequest", value: QueryFetchProviderRequest.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:QueryFetchProviderRequest: Could not create message: ' + e.message)
			}
		},
		
		protoAccAddresses({ value }: protoAccAddressesParams): EncodeObject {
			try {
				return { typeUrl: "/arkeo.arkeo.ProtoAccAddresses", value: ProtoAccAddresses.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:ProtoAccAddresses: Could not create message: ' + e.message)
			}
		},
		
		msgCloseContract({ value }: msgCloseContractParams): EncodeObject {
			try {
				return { typeUrl: "/arkeo.arkeo.MsgCloseContract", value: MsgCloseContract.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgCloseContract: Could not create message: ' + e.message)
			}
		},
		
		provider({ value }: providerParams): EncodeObject {
			try {
				return { typeUrl: "/arkeo.arkeo.Provider", value: Provider.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:Provider: Could not create message: ' + e.message)
			}
		},
		
		contractSet({ value }: contractSetParams): EncodeObject {
			try {
				return { typeUrl: "/arkeo.arkeo.ContractSet", value: ContractSet.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:ContractSet: Could not create message: ' + e.message)
			}
		},
		
		queryFetchProviderResponse({ value }: queryFetchProviderResponseParams): EncodeObject {
			try {
				return { typeUrl: "/arkeo.arkeo.QueryFetchProviderResponse", value: QueryFetchProviderResponse.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:QueryFetchProviderResponse: Could not create message: ' + e.message)
			}
		},
		
	}
};

interface QueryClientOptions {
  addr: string
}

export const queryClient = ({ addr: addr }: QueryClientOptions = { addr: "http://localhost:1317" }) => {
  return new Api({ baseURL: addr });
};

class SDKModule {
	public query: ReturnType<typeof queryClient>;
	public tx: ReturnType<typeof txClient>;
	public structure: Record<string,unknown>;
	public registry: Array<[string, GeneratedType]> = [];

	constructor(client: IgniteClient) {		
	
		this.query = queryClient({ addr: client.env.apiURL });		
		this.updateTX(client);
		this.structure =  {
						
		};
		client.on('signer-changed',(signer) => {			
		 this.updateTX(client);
		})
	}
	updateTX(client: IgniteClient) {
    const methods = txClient({
        signer: client.signer,
        addr: client.env.rpcURL,
        prefix: client.env.prefix ?? "cosmos",
    })
	
    this.tx = methods;
    for (let m in methods) {
        this.tx[m] = methods[m].bind(this.tx);
    }
	}
};

const IgntModule = (test: IgniteClient) => {
	return {
		module: {
			ArkeoArkeo: new SDKModule(test)
		},
		registry: msgTypes
  }
}
export default IgntModule;